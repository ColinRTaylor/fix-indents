// Generated by LiveScript 1.5.0
(function(){
  var p, fix;
  p = require('prelude-ls');
  fix = function(str, options){
    var countSpaces, ref$, escape, getSpaces, process;
    countSpaces = (ref$ = options != null ? options.countSpaces : void 8) != null ? ref$ : 2;
    escape = function(str){
      return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
    };
    getSpaces = function(str){
      var ref$, ref1$, ref2$;
      return (ref$ = (ref1$ = str.match(/^[ ]+/g)) != null ? (ref2$ = ref1$[0]) != null ? ref2$.length : void 8 : void 8) != null ? ref$ : 0;
    };
    process = function(previous, line){
      var findIgnore, eachIgnore, ref$, current, last, find, find2, found, shift, next, this$ = this;
      findIgnore = curry$(function(get, rule){
        return line.match(escape(get(rule)));
      });
      eachIgnore = function(get){
        if (typeof (options != null ? options.ignoreInside : void 8) !== 'Array') {
          return false;
        }
        return p.any(findIgnore(get))(
        options.ignoreInside);
      };
      if (previous.ignore === true) {
        previous.push(line);
        if (eachIgnore(function(it){
          return it[1];
        })) {
          previous.ignore = false;
        }
        return previous;
      }
      previous.ignore = eachIgnore(function(it){
        return it[0];
      });
      if (line.replace(/[ ]+/g, "").length === 0) {
        return previous;
      }
      previous.log = (ref$ = previous.log) != null
        ? ref$
        : [];
      current = {
        line: line,
        actual: getSpaces(line),
        fixed: 0
      };
      last = previous.log[previous.log.length - 1];
      find = function(actual){
        var reversed, i$, len$, item;
        reversed = p.reverse(
        previous.log);
        for (i$ = 0, len$ = reversed.length; i$ < len$; ++i$) {
          item = reversed[i$];
          if (item.actual === actual) {
            return item.fixed;
          }
        }
        return actual;
      };
      find2 = function(actual){
        var reversed, i$, len$, item;
        reversed = p.reverse(
        previous.log);
        for (i$ = 0, len$ = reversed.length; i$ < len$; ++i$) {
          item = reversed[i$];
          if (item.actual === actual) {
            return item.fixed;
          }
        }
        for (i$ = 0, len$ = reversed.length; i$ < len$; ++i$) {
          item = reversed[i$];
          if (item.actual < actual) {
            return actual - (item.actual - item.fixed);
          }
        }
        return 0;
      };
      found = find(current.actual);
      shift = current.actual + current.actual % countSpaces;
      current.fixed = (function(){
        switch (false) {
        case last != null:
          return 0;
        case found === current.actual:
          return found;
        case !(last.fixed < last.actual && last.actual === current.actual):
          return last.fixed;
        case !(last.actual < current.actual && last.fixed < current.actual):
          return last.fixed + countSpaces;
        case !(last.actual < current.actual && last.fixed === current.actual):
          return shift + countSpaces;
        case !(last.actual > current.actual && shift !== current.actual):
          return find2(current.actual);
        default:
          return current.actual;
        }
      }());
      next = line.replace(/^[ ]+/, (function(){
        var i$, to$, results$ = [];
        for (i$ = 0, to$ = current.fixed - 1; i$ <= to$; ++i$) {
          results$.push(i$);
        }
        return results$;
      }()).map(function(){
        return " ";
      }).join(""));
      previous.log.push(current);
      previous.push(next);
      return previous;
    };
    return str = p.join('\n')(
    p.foldl(process, [])(
    str.split('\n')));
  };
  module.exports = fix;
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
